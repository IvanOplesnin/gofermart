// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: worker.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addToUserBalanceUpsert = `-- name: AddToUserBalanceUpsert :exec
INSERT INTO user_balance (user_id, balance, withdrawn)
VALUES ($1, $2, 0)
ON CONFLICT (user_id)
DO UPDATE SET balance = user_balance.balance + EXCLUDED.balance
`

type AddToUserBalanceUpsertParams struct {
	UserID  int32
	Balance int32
}

func (q *Queries) AddToUserBalanceUpsert(ctx context.Context, arg AddToUserBalanceUpsertParams) error {
	_, err := q.db.Exec(ctx, addToUserBalanceUpsert, arg.UserID, arg.Balance)
	return err
}

const listPending = `-- name: ListPending :many
SELECT
    user_id,
    "number",
    "status"      AS order_status,
    uploaded_at
FROM order_numbers
WHERE
    "status" = ANY($3::text[])
    AND (next_sync_at IS NULL OR next_sync_at <= $2)
ORDER BY
    next_sync_at NULLS FIRST,
    uploaded_at
LIMIT $1
`

type ListPendingParams struct {
	Limit      int32
	NextSyncAt pgtype.Timestamptz
	Statuses   []string
}

type ListPendingRow struct {
	UserID      int32
	Number      string
	OrderStatus string
	UploadedAt  pgtype.Timestamptz
}

func (q *Queries) ListPending(ctx context.Context, arg ListPendingParams) ([]ListPendingRow, error) {
	rows, err := q.db.Query(ctx, listPending, arg.Limit, arg.NextSyncAt, arg.Statuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPendingRow
	for rows.Next() {
		var i ListPendingRow
		if err := rows.Scan(
			&i.UserID,
			&i.Number,
			&i.OrderStatus,
			&i.UploadedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOrderProcessed = `-- name: MarkOrderProcessed :one
UPDATE order_numbers
SET
    "status" = 'PROCESSED',
    accrual = $2,
    next_sync_at = NULL
WHERE
    "number" = $1
    AND user_id = $3
    AND "status" <> 'PROCESSED'
RETURNING user_id, accrual
`

type MarkOrderProcessedParams struct {
	Number  string
	Accrual pgtype.Int4
	UserID  int32
}

type MarkOrderProcessedRow struct {
	UserID  int32
	Accrual pgtype.Int4
}

func (q *Queries) MarkOrderProcessed(ctx context.Context, arg MarkOrderProcessedParams) (MarkOrderProcessedRow, error) {
	row := q.db.QueryRow(ctx, markOrderProcessed, arg.Number, arg.Accrual, arg.UserID)
	var i MarkOrderProcessedRow
	err := row.Scan(&i.UserID, &i.Accrual)
	return i, err
}

const updateFromAccrual = `-- name: UpdateFromAccrual :exec
UPDATE order_numbers
SET
    "status" = $2,
    next_sync_at = $3
WHERE
    "number" = $1
`

type UpdateFromAccrualParams struct {
	Number     string
	Status     string
	NextSyncAt pgtype.Timestamptz
}

func (q *Queries) UpdateFromAccrual(ctx context.Context, arg UpdateFromAccrualParams) error {
	_, err := q.db.Exec(ctx, updateFromAccrual, arg.Number, arg.Status, arg.NextSyncAt)
	return err
}

const updateSyncTime = `-- name: UpdateSyncTime :exec
UPDATE order_numbers
SET next_sync_at = $2
WHERE "number" = $1
`

type UpdateSyncTimeParams struct {
	Number     string
	NextSyncAt pgtype.Timestamptz
}

func (q *Queries) UpdateSyncTime(ctx context.Context, arg UpdateSyncTimeParams) error {
	_, err := q.db.Exec(ctx, updateSyncTime, arg.Number, arg.NextSyncAt)
	return err
}
