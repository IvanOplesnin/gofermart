// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: withdraws.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addWithdrawal = `-- name: AddWithdrawal :exec
INSERT INTO withdraws (user_id, order_number, summa, processed_at)
VALUES ($1, $2, $3, $4)
`

type AddWithdrawalParams struct {
	UserID      int32
	OrderNumber string
	Summa       int32
	ProcessedAt pgtype.Timestamptz
}

func (q *Queries) AddWithdrawal(ctx context.Context, arg AddWithdrawalParams) error {
	_, err := q.db.Exec(ctx, addWithdrawal,
		arg.UserID,
		arg.OrderNumber,
		arg.Summa,
		arg.ProcessedAt,
	)
	return err
}

const balnceByUserID = `-- name: BalnceByUserID :one
SELECT id, user_id, balance, withdrawn
FROM user_balance
WHERE user_id = $1
LIMIT 1
`

func (q *Queries) BalnceByUserID(ctx context.Context, userID int32) (UserBalance, error) {
	row := q.db.QueryRow(ctx, balnceByUserID, userID)
	var i UserBalance
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Balance,
		&i.Withdrawn,
	)
	return i, err
}

const ensureBalanceRow = `-- name: EnsureBalanceRow :exec
INSERT INTO user_balance (user_id, balance, withdrawn)
VALUES ($1, 0, 0)
ON CONFLICT (user_id) DO NOTHING
`

func (q *Queries) EnsureBalanceRow(ctx context.Context, userID int32) error {
	_, err := q.db.Exec(ctx, ensureBalanceRow, userID)
	return err
}

const listWithdraws = `-- name: ListWithdraws :many
SELECT id, user_id, order_number, summa, processed_at
FROM withdraws
WHERE user_id = $1
ORDER BY processed_at DESC
`

func (q *Queries) ListWithdraws(ctx context.Context, userID int32) ([]Withdraw, error) {
	rows, err := q.db.Query(ctx, listWithdraws, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Withdraw
	for rows.Next() {
		var i Withdraw
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrderNumber,
			&i.Summa,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockBalanceRow = `-- name: LockBalanceRow :one
SELECT balance, withdrawn
FROM user_balance
WHERE user_id = $1
FOR UPDATE
`

type LockBalanceRowRow struct {
	Balance   int32
	Withdrawn int32
}

func (q *Queries) LockBalanceRow(ctx context.Context, userID int32) (LockBalanceRowRow, error) {
	row := q.db.QueryRow(ctx, lockBalanceRow, userID)
	var i LockBalanceRowRow
	err := row.Scan(&i.Balance, &i.Withdrawn)
	return i, err
}

const withdrawIfEnough = `-- name: WithdrawIfEnough :one
UPDATE user_balance
SET
  balance   = balance - $2,
  withdrawn = withdrawn + $2
WHERE user_id = $1
  AND balance >= $2
RETURNING balance, withdrawn
`

type WithdrawIfEnoughParams struct {
	UserID int32
	Summa  int32
}

type WithdrawIfEnoughRow struct {
	Balance   int32
	Withdrawn int32
}

func (q *Queries) WithdrawIfEnough(ctx context.Context, arg WithdrawIfEnoughParams) (WithdrawIfEnoughRow, error) {
	row := q.db.QueryRow(ctx, withdrawIfEnough, arg.UserID, arg.Summa)
	var i WithdrawIfEnoughRow
	err := row.Scan(&i.Balance, &i.Withdrawn)
	return i, err
}
